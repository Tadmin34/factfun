<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>S·ª± Th·∫≠t V√¥ B·ªï</title>
  <style>
    /* Global Styles */

    
    body {
      margin: 0;
      font-family: 'Arial', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      background-color: #ff007f; /* M√†u h·ªìng ƒë·∫≠m */
      color: #fff;
      padding: 20px;
      overflow-x: hidden;
      transition: opacity 0.3s ease;
      cursor: url("/image-removebg-preview (2).png"), auto;

    }

    .container {
      text-align: cen8px;
    width: 60%;
    border-radius: 5px;
  }
  .weather-container p {
    margin: 3px 0;
  }
}

  </style>
</head>
<body>
  

  <div class="weather-container" id="weather-container">
    <p id="location">ƒê·ªãa ƒëi·ªÉm: --</p>
    <p id="temperature">Nhi·ªát ƒë·ªô: --¬∞C</p>
    <p id="weather">Th·ªùi ti·∫øt: --</p>
    <p id="time">Th·ªùi gian: --</p>
  </div>
  
  <div class="loader-container" id="loader-container"><!-- Loader -->
  <div class="loader" id="loader"></div>
<h2>ü•∞ƒêang t√¨m s·ª± th·∫≠tü•∞</h2></div>

  <div class="container">
    <h1>S·ª± Th·∫≠t B·∫•t Ng·ªù</h1>

    <div class="images-container">
      <div>
        <img id="waifu-image" src="" alt="Image" />
      </div>
      <div>
        <img id="neko-image" src="" alt="Image" />
      </div>
    </div>

    <div class="fact" id="fact"></div>

    <button id="reload-button">Reload</button>


  </div>

  <script>
    // API URL cho s·ª± th·∫≠t v√† ·∫£nh Neko
    const factUrl = 'https://uselessfacts.jsph.pl/random.json?language=en';
    const nekoUrl = 'https://api.nekosapi.com/v3/images/random';

    // Bi·∫øn ƒëi·ªÅu ch·ªânh loader opacity
    let loaderOpacity = 0;

    // H√†m l·∫•y s·ª± th·∫≠t ng·∫´u nhi√™n
    async function fetchRandomFact() {
      const response = await fetch(factUrl);
      const data = await response.json();
      const fact = data.text;
      document.getElementById('fact').textContent = await translateFact(fact);
    }

    // H√†m d·ªãch s·ª± th·∫≠t sang ti·∫øng Vi·ªát
    async function translateFact(fact) {
      const translateUrl = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(fact)}&langpair=en|vi`;
      const response = await fetch(translateUrl);
      const data = await response.json();
      return data.responseData.translatedText;
    }

    // H√†m l·∫•y ·∫£nh Neko t·ª´ nekos.best
    async function fetchNekoImage() {
    const response = await fetch(nekoUrl);
    const data = await response.json();

    const nekoImage = document.getElementById('neko-image');
    nekoImage.src = data.items
      .filter(item => item.tags.some(tag => tag.is_nsfw === true))  // Filter NSFW content (optional)
      .map(item => item.image_url)[0];

    // Add click event listener to Neko image
    nekoImage.addEventListener('click', () => {
      window.location.href = nekoImage.src; // Redirect to image URL
    });
  }

  // Function to fetch Waifu image with click event handling
  async function fetchWaifuImage() {
    const waifuApiUrl = 'https://api.waifu.pics/sfw/waifu';
    const response = await fetch(waifuApiUrl);
    const data = await response.json();

    const waifuImage = document.getElementById('waifu-image');
    waifuImage.src = data.url;

    // Add click event listener to Waifu image
    waifuImage.addEventListener('click', () => {
      window.location.href = waifuImage.src; // Redirect to image URL
    })};

    // H√†m kh·ªüi t·∫°o trang khi load
    async function initPage() {
      //
      showLoader(true); 
      await fetchRandomFact();
      await fetchWaifuImage();
      await fetchNekoImage();
      showLoader(false); 
    }

    // H√†m hi·ªÉn th·ªã/·∫©n loader
    function showLoader(isVisible) {
  loaderOpacity = isVisible ? 1 : 0;
  document.getElementById('loader').style.opacity = loaderOpacity;
  document.getElementById('loader-container').style.display = isVisible ? 'flex' : 'none';
}

    // L√†m m·ªõi khi nh·∫•n n√∫t
   // H√†m l√†m m·ªõi s·ª± ki·ªán khi nh·∫•n n√∫t

   document.getElementById('reload-button').addEventListener('click', initPage);

    // Kh·ªüi t·∫°o trang ngay khi m·ªü
    initPage();
    // OpenWeatherMap API Key
// OpenWeatherMap API Key
const API_KEY = "062d92a2646152d39eb7845a608226cb";

async function getWeatherAndLocation() {
  if (navigator.geolocation) {
    try {
      // L·∫•y v·ªã tr√≠ ng∆∞·ªùi d√πng
      const position = await new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, reject);
      });
      const { latitude, longitude } = position.coords;

      // S·ª≠ d·ª•ng reverse geocoding ƒë·ªÉ l·∫•y ƒë·ªãa ch·ªâ
      const reverseGeocodingResponse = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}`);
      const reverseGeocodingData = await reverseGeocodingResponse.json();
      const address = reverseGeocodingData.address.city || "H√† N·ªôi";
      document.getElementById("location").textContent = `ƒê·ªãa ƒëi·ªÉm: ${address}`;

      // G·ªçi OpenWeatherMap API ƒë·ªÉ l·∫•y th√¥ng tin th·ªùi ti·∫øt
      const weatherResponse = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${latitude}&lon=${longitude}&lang=vi&units=metric&appid=${API_KEY}`);
      const weatherData = await weatherResponse.json();
      const temperature = weatherData.main.temp; // Nhi·ªát ƒë·ªô
      const weather = weatherData.weather[0].description; // Th·ªùi ti·∫øt m√¥ t·∫£
      document.getElementById("temperature").textContent = `Nhi·ªát ƒë·ªô: ${temperature}¬∞C`;
      document.getElementById("weather").textContent = `Th·ªùi ti·∫øt: ${weather}`;
    } catch (error) {
      console.error("L·ªói khi l·∫•y v·ªã tr√≠ ho·∫∑c th√¥ng tin th·ªùi ti·∫øt:", error);
      // Khi kh√¥ng t√¨m th·∫•y v·ªã tr√≠, s·ª≠ d·ª•ng ƒë·ªãa ch·ªâ m·∫∑c ƒë·ªãnh (H√† N·ªôi)
      const defaultCity = "H√† N·ªôi";
      document.getElementById("location").textContent = `ƒê·ªãa ƒëi·ªÉm: ${defaultCity}`;

      // G·ªçi OpenWeatherMap API ƒë·ªÉ l·∫•y th√¥ng tin th·ªùi ti·∫øt cho H√† N·ªôi
      const weatherResponse = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=${defaultCity}&lang=vi&units=metric&appid=${API_KEY}`);
      const weatherData = await weatherResponse.json();
      const temperature = weatherData.main.temp; // Nhi·ªát ƒë·ªô
      const weather = weatherData.weather[0].description; // Th·ªùi ti·∫øt m√¥ t·∫£
      document.getElementById("temperature").textContent = `Nhi·ªát ƒë·ªô: ${temperature}¬∞C`;
      document.getElementById("weather").textContent = `Th·ªùi ti·∫øt: ${weather}`;
    }
  } else {
    document.getElementById("location").textContent = "Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Geolocation.";
    // N·∫øu kh√¥ng h·ªó tr·ª£ Geolocation, d√πng m·∫∑c ƒë·ªãnh H√† N·ªôi
    const defaultCity = "H√† N·ªôi";
    document.getElementById("location").textContent = `ƒê·ªãa ƒëi·ªÉm: ${defaultCity}`;

    // G·ªçi OpenWeatherMap API ƒë·ªÉ l·∫•y th√¥ng tin th·ªùi ti·∫øt cho H√† N·ªôi
    const weatherResponse = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=${defaultCity}&lang=vi&units=metric&appid=${API_KEY}`);
    const weatherData = await weatherResponse.json();
    const temperature = weatherData.main.temp; // Nhi·ªát ƒë·ªô
    const weather = weatherData.weather[0].description; // Th·ªùi ti·∫øt m√¥ t·∫£
    document.getElementById("temperature").textContent = `Nhi·ªát ƒë·ªô: ${temperature}¬∞C`;
    document.getElementById("weather").textContent = `Th·ªùi ti·∫øt: ${weather}`;
  }
}

// G·ªçi h√†m ƒë·ªÉ l·∫•y th√¥ng tin th·ªùi ti·∫øt v√† ƒë·ªãa ch·ªâ
getWeatherAndLocation();

// C·∫≠p nh·∫≠t th·ªùi gian hi·ªán t·∫°i
setInterval(() => {
  const now = new Date();
  const formattedTime = now.toLocaleTimeString("vi-VN", { hour: "2-digit", minute: "2-digit", second: "2-digit" });
  document.getElementById("time").textContent = `Th·ªùi gian: ${formattedTime}`;
}, 1000);



  </script>

</body>
</html>
